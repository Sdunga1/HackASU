from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from typing import List, Optional

# Import dashboard manager and data (avoid circular import by importing here)
try:
    from app.routes.dashboard import manager, dashboard_data
except ImportError:
    # Fallback if dashboard module not yet loaded
    manager = None
    dashboard_data = None

router = APIRouter()

# In-memory storage for sprints (in production, use a database)
sprints_storage = {
    "srs_document": None,
    "sprints": [],
    "last_updated": None
}


class SprintSyncRequest(BaseModel):
    """Request model for syncing sprints to dashboard (sprints already generated by Cursor)"""
    sprints: List[dict]  # List of sprint objects with user stories
    srs_document: Optional[dict] = None  # Optional SRS document metadata
    document_name: Optional[str] = None
    document_url: Optional[str] = None


class UserStory(BaseModel):
    id: str
    title: str
    description: str
    storyPoints: int
    priority: str
    status: str
    assignee: Optional[str] = None
    acceptanceCriteria: List[str]


class Sprint(BaseModel):
    id: str
    name: str
    goal: str
    startDate: str
    endDate: str
    totalStoryPoints: int
    completedStoryPoints: int
    progress: int
    userStories: List[UserStory]


class SRSDocument(BaseModel):
    id: str
    name: str
    url: Optional[str] = None
    lastUpdated: str
    totalRequirements: int
    status: str


@router.post("/sync-sprints")
async def sync_sprints_to_dashboard(request: SprintSyncRequest):
    """
    Sync sprints and user stories to dashboard
    
    Accepts sprints generated by Cursor's AI and stores them in the dashboard.
    Used by the send_sprints_to_dashboard MCP tool.
    """
    try:
        if not request.sprints or len(request.sprints) == 0:
            raise HTTPException(
                status_code=400,
                detail="Sprints data is required"
            )
        
        from datetime import datetime
        
        # Store sprints
        sprints_storage["sprints"] = request.sprints
        sprints_storage["last_updated"] = datetime.utcnow().isoformat()
        
        # Store SRS document metadata if provided
        if request.srs_document:
            sprints_storage["srs_document"] = request.srs_document
        elif request.document_name:
            sprints_storage["srs_document"] = {
                "id": "srs-001",
                "name": request.document_name,
                "url": request.document_url,
                "lastUpdated": datetime.utcnow().isoformat(),
                "totalRequirements": sum(len(sprint.get("userStories", [])) for sprint in request.sprints),
                "status": "ready"
            }
        
        # Update dashboard_data for WebSocket broadcasting
        if dashboard_data is not None:
            dashboard_data["sprints"] = request.sprints
            if sprints_storage.get("srs_document"):
                dashboard_data["srs_document"] = sprints_storage["srs_document"]
            dashboard_data["last_updated"] = sprints_storage["last_updated"]
            
            # Broadcast to all connected WebSocket clients
            if manager is not None:
                await manager.broadcast({
                    "type": "sprints_update",
                    "data": {
                        "sprints": request.sprints,
                        "srs_document": sprints_storage.get("srs_document"),
                        "last_updated": sprints_storage["last_updated"]
                    }
                })
        
        return {
            "status": "success",
            "message": f"Successfully synced {len(request.sprints)} sprints to dashboard",
            "sprints_count": len(request.sprints),
            "sprints": request.sprints
        }
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/document")
async def get_srs_document():
    """
    Get current SRS document information
    """
    if not sprints_storage["srs_document"]:
        return {
            "status": "not_found",
            "message": "No SRS document loaded"
        }
    
    return {
        "status": "success",
        "document": sprints_storage["srs_document"]
    }


@router.get("/sprints")
async def get_sprints():
    """
    Get all generated sprints
    """
    return {
        "status": "success",
        "sprints": sprints_storage["sprints"],
        "count": len(sprints_storage["sprints"]),
        "last_updated": sprints_storage["last_updated"]
    }


@router.get("/sprints/{sprint_id}")
async def get_sprint(sprint_id: str):
    """
    Get a specific sprint by ID
    """
    sprints = sprints_storage["sprints"]
    sprint = next((s for s in sprints if s.get("id") == sprint_id), None)
    
    if not sprint:
        raise HTTPException(status_code=404, detail="Sprint not found")
    
    return {
        "status": "success",
        "sprint": sprint
    }


class UpdateStatusRequest(BaseModel):
    status: str

@router.post("/sprints/{sprint_id}/user-stories/{story_id}/update")
async def update_user_story_status(
    sprint_id: str,
    story_id: str,
    request: UpdateStatusRequest
):
    """
    Update user story status
    """
    sprints = sprints_storage["sprints"]
    sprint = next((s for s in sprints if s.get("id") == sprint_id), None)
    
    if not sprint:
        raise HTTPException(status_code=404, detail="Sprint not found")
    
    user_stories = sprint.get("userStories", [])
    story = next((s for s in user_stories if s.get("id") == story_id), None)
    
    if not story:
        raise HTTPException(status_code=404, detail="User story not found")
    
    story["status"] = request.status
    
    # Update sprint progress
    completed_stories = [s for s in user_stories if s.get("status") == "done"]
    sprint["completedStoryPoints"] = sum(s.get("storyPoints", 0) for s in completed_stories)
    total_points = sprint.get("totalStoryPoints", 1)
    sprint["progress"] = int((sprint["completedStoryPoints"] / total_points) * 100) if total_points > 0 else 0
    
    return {
        "status": "success",
        "message": f"User story {story_id} updated to {request.status}",
        "sprint": sprint
    }

